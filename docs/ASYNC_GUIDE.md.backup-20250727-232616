# ü§ñ Integraci√≥n As√≠ncrona: Codex + AI Foundry

## üìã Arquitectura H√≠brida de Agentes

El proyecto utiliza una arquitectura h√≠brida que combina:
- **Agentes Codex**: Para tareas rutinarias y desarrollo diario (80%)
- **AI Foundry (Azure OpenAI)**: Para an√°lisis complejo y refactorizaci√≥n (20%)

## üîÑ Flujo de Trabajo As√≠ncrono

```mermaid
graph TD
    A[Nueva Tarea] --> B{Complejidad?}
    B -->|Baja-Media| C[Agente Codex]
    B -->|Alta| D[An√°lisis Inicial Codex]
    D --> E[Invocar AI Foundry Async]
    E --> F[An√°lisis Profundo]
    F --> G[Callback con Resultados]
    G --> H[Implementaci√≥n Codex]
    C --> I[Resultado]
    H --> I[Resultado]
```

## üöÄ Ejemplos de Uso

### 1. An√°lisis As√≠ncrono de Componente Complejo

```javascript
// Comando para Mobile_App_Agent
@codex analyze-component --file HomeScreen.tsx --async

// Flujo interno:
// 1. Mobile_App_Agent hace scan inicial (s√≠ncrono)
// 2. Si complejidad > 15, invoca ReadTsxAgent (as√≠ncrono)
// 3. ReadTsxAgent analiza en background usando GPT-4o
// 4. Callback notifica cuando est√° listo
// 5. Mobile_App_Agent presenta resultados
```

**Respuesta esperada:**
```json
{
  "taskId": "analysis-12345",
  "status": "processing",
  "estimatedTime": "2-3 minutes",
  "callbackUrl": "http://localhost:5000/webhook/callback/analysis-12345"
}
```

### 2. Optimizaci√≥n de Performance con M√∫ltiples Agentes

```bash
# Trigger manual
@codex optimize-performance --module mobile-app --async --priority high
```

### 3. Generaci√≥n de Tests en Batch

```javascript
// Para generar tests de m√∫ltiples componentes
@codex generate-tests --pattern "src/screens/**/*.tsx" --async --batch
```

## üîß Configuraci√≥n de AI Foundry

### Deployment Activo: ReadTsxAgent
- **Modelo**: GPT-4o (2024-05-13)
- **Endpoint**: `https://boatrentalfoundry-dev.openai.azure.com/openai/deployments/ReadTsxAgent/chat/completions`
- **Rate Limits**: 10 RPM, 10,000 tokens/min
- **Capacidades**: 128K contexto, 4K output

### Agentes Especializados Disponibles
| Agente | Modelo | Use Case | Integration |
|--------|--------|----------|-------------|
| ReadTsxAgent | GPT-4o | An√°lisis TSX complejo | Mobile_App_Agent |
| RefactorAgent | GPT-4 | Refactorizaci√≥n | Mobile_App_Agent, Backend_Agent |
| PerformanceOptimizer | GPT-3.5 | Optimizaci√≥n | Mobile_App_Agent, Backend_Agent |
| TestingExpert | GPT-3.5 | Generaci√≥n tests | Todos los agentes |
| ArchitectureAnalyzer | GPT-4 | An√°lisis arquitectura | Architect_BoatRental |

## üìä Triggers Autom√°ticos

Los agentes AI Foundry se invocan autom√°ticamente cuando:

1. **Complejidad Ciclom√°tica > 15**
   - Trigger: RefactorAgent
   - Notifica: Agente responsable del m√≥dulo

2. **Archivo > 500 l√≠neas**
   - Trigger: ReadTsxAgent (para TSX) o RefactorAgent (otros)
   - Notifica: Mobile_App_Agent o Backend_Agent

3. **Cobertura de Tests < 70%**
   - Trigger: TestingExpert
   - Notifica: Todos los agentes relevantes

4. **Performance Regression Detectada**
   - Trigger: PerformanceOptimizer
   - Notifica: Mobile_App_Agent + Backend_Agent

## üõ†Ô∏è Comandos de Invocaci√≥n

```bash
# An√°lisis de componente TSX
@codex invoke-foundry --agent ReadTsxAgent --file mobile-app/src/screens/home/HomeScreen.tsx

# Refactorizaci√≥n compleja
@codex invoke-foundry --agent RefactorAgent --complexity high --module mobile-app

# An√°lisis de arquitectura
@codex invoke-foundry --agent ArchitectureAnalyzer --scope full-project

# Verificar estado de tareas as√≠ncronas
@codex status --async
```

## üìà Monitoreo de Tareas As√≠ncronas

```bash
# Ver todas las tareas en progreso
@codex status --async

# Output:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Task ID     ‚îÇ Type             ‚îÇ Agent    ‚îÇ Status  ‚îÇ Progress  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ tsx-98765   ‚îÇ Component Analysis‚îÇ ReadTsx  ‚îÇ Running ‚îÇ 45%       ‚îÇ
‚îÇ perf-54321  ‚îÇ Performance      ‚îÇ PerfOpt  ‚îÇ Queued  ‚îÇ 0%        ‚îÇ
‚îÇ test-11111  ‚îÇ Test Generation  ‚îÇ TestExp  ‚îÇ Running ‚îÇ 78%       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### M√©tricas en Tiempo Real

```javascript
// Webhook notification
POST /webhook/callback
{
  "taskId": "tsx-98765",
  "status": "completed",
  "agent": "ReadTsxAgent",
  "results": {
    "complexity": 18,
    "lines": 523,
    "dependencies": 12,
    "suggestions": [
      "Split into 3 smaller components",
      "Extract custom hooks",
      "Optimize re-renders"
    ]
  },
  "metrics": {
    "executionTime": 45000,
    "tokensUsed": 3500,
    "cost": 0.14
  }
}
```

## üîÑ Patrones de Integraci√≥n

### Pattern 1: Fire and Forget
```javascript
// Para tareas no cr√≠ticas
async function analyzeInBackground(file) {
  const taskId = await codex.analyzeAsync(file, {
    priority: 'low',
    callback: false
  });
  
  console.log(`Analysis started: ${taskId}`);
  // No esperar resultado
}
```

### Pattern 2: Async/Await con Polling
```javascript
// Para tareas cr√≠ticas
async function refactorWithAI(component) {
  const taskId = await codex.refactorAsync(component, {
    priority: 'high',
    agent: 'RefactorAgent'
  });
  
  // Polling cada 5 segundos
  const result = await codex.waitForCompletion(taskId, {
    pollInterval: 5000,
    timeout: 300000
  });
  
  return result;
}
```

### Pattern 3: Event-Driven con Callbacks
```javascript
// Para flujos complejos
async function complexWorkflow(module) {
  const workflow = await codex.startWorkflow('performance_optimization', {
    module,
    callbacks: {
      onStepComplete: (step) => console.log(`Step ${step.id} completed`),
      onError: (error) => handleError(error),
      onComplete: (results) => applyOptimizations(results)
    }
  });
  
  return workflow.id;
}
```

## üõ°Ô∏è Manejo de Errores y Recuperaci√≥n

### Retry Autom√°tico
```javascript
// Configuraci√≥n en mcpconfig.json activa retry autom√°tico
{
  "retry_policy": {
    "max_attempts": 3,
    "backoff": "exponential",
    "on_errors": ["rate_limit", "timeout", "transient"]
  }
}
```

### Circuit Breaker
```javascript
// Protecci√≥n contra fallos en cascada
if (await codex.isCircuitOpen('ai_foundry')) {
  console.log('AI Foundry temporarily unavailable, using Codex only');
  return await codex.executeSync(task);
}
```

## üìà Optimizaci√≥n de Costos

### Estrategias de Ahorro

1. **Cach√© Inteligente**
   ```javascript
   // Resultados se cachean autom√°ticamente
   const cached = await codex.checkCache('tsx-analysis', file.hash);
   if (cached) return cached;
   ```

2. **Batching de Requests**
   ```javascript
   // Agrupar an√°lisis similares
   const files = await glob('src/**/*.tsx');
   const results = await codex.batchAnalyze(files, {
     batchSize: 20,
     useCheaperModel: true
   });
   ```

3. **Priorizaci√≥n Inteligente**
   ```javascript
   // Solo usar AI Foundry para alta complejidad
   if (complexity < 10) {
     return await codex.analyzeLocal(file);
   } else {
     return await codex.analyzeWithFoundry(file);
   }
   ```

## üîç Debugging As√≠ncrono

### Tracing Distribuido
```bash
# Ver trace completo de una tarea
@codex trace --task-id tsx-98765

# Output:
[2024-01-10 10:00:00] START Mobile_App_Agent.scan
[2024-01-10 10:00:02] COMPLETE complexity=18
[2024-01-10 10:00:03] INVOKE ReadTsxAgent (async)
[2024-01-10 10:00:03] QUEUED priority=high
[2024-01-10 10:00:05] PROCESSING ReadTsxAgent
[2024-01-10 10:00:45] COMPLETE analysis done
[2024-01-10 10:00:46] CALLBACK sent
[2024-01-10 10:00:47] INVOKE RefactorAgent (async)
...
```

### Logs Centralizados
```javascript
// Todos los logs as√≠ncronos van a Azure Log Analytics
const logs = await codex.queryLogs({
  timeRange: 'last_hour',
  filter: 'agent:*foundry* AND status:error',
  limit: 100
});
```

## üéØ Best Practices

1. **Siempre especificar timeouts**
2. **Usar callbacks para tareas largas**
3. **Implementar idempotencia**
4. **Monitorear rate limits**
5. **Cachear resultados costosos**
6. **Usar prioridades apropiadas**
7. **Implementar circuit breakers**
8. **Log de m√©tricas de costo**

## üí∞ Consideraciones de Costo

### Uso Eficiente
- **Codex First**: Siempre intentar con agentes Codex primero
- **Batch Operations**: Agrupar an√°lisis complejos
- **Cache Results**: Los resultados de AI Foundry se cachean por 24h
- **Rate Limiting**: Respetar l√≠mites (6 req/min para GPT-3.5)

### Presupuesto Mensual Sugerido
- Desarrollo activo: 80% Codex, 20% AI Foundry
- Mantenimiento: 95% Codex, 5% AI Foundry
- Refactorizaci√≥n mayor: 60% Codex, 40% AI Foundry

## üìä M√©tricas de √âxito

| M√©trica | Target | Medici√≥n |
|---------|--------|----------|
| Tiempo de resoluci√≥n | -30% | Con AI Foundry vs sin |
| Calidad del c√≥digo | +25% | Score de complejidad |
| Cobertura de tests | >85% | Jest coverage |
| Bugs post-refactor | <5% | Issues reportados |

## üîß Configuraci√≥n Recomendada

```yaml
# En .codegpt.yaml
ai_foundry:
  enabled: true
  auto_invoke: true
  complexity_threshold: 15
  file_size_threshold: 500
  test_coverage_threshold: 70
  
  agents:
    - ReadTsxAgent
    - RefactorAgent
    - ArchitectureAnalyzer
    - PerformanceOptimizer
    - TestingExpert
```

---

*Este documento debe actualizarse mensualmente bas√°ndose en m√©tricas de uso y feedback del equipo.*